package awt.user;

import java.lang.invoke.MethodHandles;
import java.time.*;
import java.util.UUID;

import javax.persistence.*;
import javax.validation.constraints.NotNull;
import javax.xml.bind.Marshaller;
import javax.xml.bind.annotation.*;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

import org.slf4j.*;

import awt.util.*;
import io.swagger.annotations.*;

/**
 * Object representation of a user.
 *
 * @author awt
 */
@ApiModel(value = "User", description = "User representation")
@Entity
@Table(name = "USERS")
@XmlRootElement(name = "user")
@XmlAccessorType(XmlAccessType.NONE)
public class User {
    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());

    @ApiModelProperty(value = "User id. Unique value typically autogenerated by system.", readOnly = true)
    @Id
    @Column(name = "USER_ID", unique = true, updatable = false, nullable = false)
    @XmlElement(name = "id")
    @XmlJavaTypeAdapter(UUIDAdapter.class)
    private UUID id;

    @ApiModelProperty(value = "Username")
    @Column(name = "USERNAME", unique = true, nullable = false)
    @NotNull(message = "uid cannot be null.", groups = { ValidationGroup.Create.class, ValidationGroup.Update.class })
    @XmlElement(name = "uid")
    private String uid;

    @ApiModelProperty(value = "Password. Will never be returned in payload")
    @XmlElement(name = "pwd")
    private String password;

    @ApiModelProperty(value = "First name")
    @Column(name = "FIRST_NAME", nullable = false)
    @NotNull(message = "firstName cannot be null.", groups = { ValidationGroup.Create.class,
	    ValidationGroup.Update.class })
    @XmlElement(name = "firstName")
    private String firstName;

    @ApiModelProperty(value = "Last name")
    @Column(name = "LAST_NAME", nullable = false)
    @NotNull(message = "lastName cannot be null.", groups = { ValidationGroup.Create.class,
	    ValidationGroup.Update.class })
    @XmlElement(name = "lastName")
    private String lastName;

    @ApiModelProperty(value = "Email address")
    @Column(name = "EMAIL_ADDRESS", nullable = false)
    @NotNull(message = "email cannot be null.", groups = { ValidationGroup.Create.class, ValidationGroup.Update.class })
    @XmlElement(name = "email")
    private String email;

    @ApiModelProperty(value = "Creation date")
    @Column(name = "CREATION_DATE", nullable = false, updatable = false)
    @XmlElement(name = "creationDate")
    @XmlJavaTypeAdapter(OffsetDateTimeAdapter.class)
    private OffsetDateTime creationDate;

    @ApiModelProperty(value = "Update date")
    @Column(name = "UPDATE_DATE", nullable = false)
    @XmlElement(name = "updateDate")
    @XmlJavaTypeAdapter(OffsetDateTimeAdapter.class)
    private OffsetDateTime updateDate;

    public UUID getId() {
	return this.id;
    }

    public void setId(final UUID id) {
	this.id = id;
    }

    public String getUid() {
	return this.uid;
    }

    public void setUid(final String uid) {
	this.uid = uid;
    }

    public String getFirstName() {
	return this.firstName;
    }

    public void setFirstName(final String firstName) {
	this.firstName = firstName;
    }

    public String getLastName() {
	return this.lastName;
    }

    public void setLastName(final String lastName) {
	this.lastName = lastName;
    }

    public String getEmail() {
	return this.email;
    }

    public void setEmail(final String email) {
	this.email = email;
    }

    public String getPassword() {
	return this.password;
    }

    public void setPassword(final String password) {
	this.password = password;
    }

    public OffsetDateTime getCreationDate() {
	return this.creationDate;
    }

    public void setCreationDate(final OffsetDateTime creationDate) {
	this.creationDate = creationDate;
    }

    public OffsetDateTime getUpdateDate() {
	return this.updateDate;
    }

    public void setUpdateDate(final OffsetDateTime updateDate) {
	this.updateDate = updateDate;
    }

    public void delete() {
	LOGGER.info("Deleting user '{}'", this.id);
	// XXX update code to remove from external datasource
    }

    public void update() {
	LOGGER.info("Updating user '{}' with the following information '{}'", this.id, this);
	// XXX update code to save into external datasource
	this.beforeUpdate(); // this will be call automatically once we start using JPA
    }

    public void create() {
	LOGGER.info("Creating user with the following information '{}'", this);
	// XXX update code to save into external datasource
	this.beforeInsert(); // this will be call automatically once we start using JPA
    }

    public void login() {
	// XXX update code to authenticate from external datasource
    }

    public static User getUser(final UUID id) {
	LOGGER.info("Retrieving user '{}'", id);
	// XXX update code to read from external datasource
	final User user = new User();
	user.setId(id);
	user.setUid("at");
	user.setFirstName("A1");
	user.setLastName("T1");
	user.setEmail("a@t.com");
	user.setCreationDate(OffsetDateTime.now(ZoneOffset.UTC));
	user.setUpdateDate(OffsetDateTime.now(ZoneOffset.UTC));
	return user;
    }

    @Override
    public String toString() {
	return "User [id=" + this.id + ", uid=" + this.uid + ", firstName=" + this.firstName + ", lastName="
		+ this.lastName + ", email=" + this.email + "]";
    }

    /**
     * Primarily used to perform entity filtering.
     *
     * @param marshaller
     *
     * @see <a href=
     *      "https://docs.oracle.com/javase/6/docs/api/javax/xml/bind/Marshaller.html#marshalEventCallback">Marshal
     *      Event Callbacks</a>
     */
    protected void beforeMarshal(final Marshaller marshaller) {
	// NOTE: the JAXB event callbacks do not work correctly within JerseyTest as
	// events are called at the wrong times. Verified this works when deployed to
	// Tomcat

	// never return password
	this.password = null; // NOPMD
    }

    @PrePersist
    protected void beforeInsert() {
	this.id = UUID.randomUUID();
	this.creationDate = OffsetDateTime.now(ZoneOffset.UTC);
	this.updateDate = OffsetDateTime.now(ZoneOffset.UTC);
    }

    @PreUpdate
    protected void beforeUpdate() {
	this.updateDate = OffsetDateTime.now(ZoneOffset.UTC);
    }
}